#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant Community Add-on: Tailscale
# Runs after the machine has been logged in into the Tailscale network
# ==============================================================================
declare -a options
declare -a routes=()
declare -a colliding_routes=()
declare login_server
declare tags

# Default options
options+=(--accept-routes)
options+=(--hostname "$(bashio::info.hostname)")

# Accept magicDNS by default when not set, or when explicitly enabled
if ! bashio::config.has_value "accept_dns" || \
  bashio::config.true "accept_dns";
then
  options+=(--accept-dns)
else
  options+=(--accept-dns=false)
fi

# Advertise as exit node by default when not set, or when explicitly enabled
if ! bashio::config.has_value "advertise_exit_node" || \
  bashio::config.true "advertise_exit_node";
then
  options+=(--advertise-exit-node)
else
  options+=(--advertise-exit-node=false)
fi

# Get configured control server
if bashio::config.has_value "login_server";
then
  login_server=$(bashio::config "login_server")
  options+=(--login-server="${login_server}")
fi

# Due to removed experimental feature we must add back once used non-default options
options+=(--snat-subnet-routes)

# Get configured tags
tags=$(bashio::config "tags//[] | join(\",\")" "")
options+=(--advertise-tags="${tags}")

# Find interfaces and matching addresses and extract routes to be advertised
readarray -t routes < <(subnet-routes)
IFS=","
options+=(--advertise-routes="${routes[*]}")
unset IFS

# Wait for the network to be available and logged in
while ! bashio::fs.socket_exists "/var/run/tailscale/tailscaled.sock" || \
  ! /opt/tailscale status --json --peers=false --self=false \
    | jq --exit-status '.BackendState == "Running" or .BackendState == "NeedsLogin"' > /dev/null;
do
  sleep 2
done

# Start Tailscale
if ! /opt/tailscale up "${options[@]}"; then
  bashio::log.error "Unable to start up Tailscale"
  bashio::exit.nok
fi

# Wait for the network to be available and logged in
while ! /opt/tailscale status --json --peers=false --self=false \
  | jq --exit-status '.BackendState == "Running"' > /dev/null
do
  sleep 2
done

bashio::log.info "Tailscale is running"

# In case of non userspace networking, clamp the MSS to the MTU for all advertised subnet's interface
# If user later enables subnet routing for site-to-site networking, these settings are already there
# Source: https://tailscale.com/kb/1214/site-to-site/ Step 1 / Point 4
if bashio::config.false "userspace_networking"; then
  for interface in $(bashio::network.interfaces); do
    bashio::log.info "Clamp the MSS to the MTU for interface ${interface}"
    iptables -t mangle -A FORWARD -i tailscale0 -o ${interface} -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
  done
fi

# Notify about colliding subnet routes
readarray -t colliding_routes < <(comm -1 -2 \
  <(printf '%s\n' "${routes[@]}") \
  <(/opt/tailscale status --json --peers=true --self=false \
    | jq -rc '.Peer[] | select(has("PrimaryRoutes")) | .PrimaryRoutes[]' \
    | sort -u))
if (( 0 < ${#colliding_routes[@]} )); then
  bashio::log.warning "Currently the following subnets are both present as local subnets"
  bashio::log.warning "and are also routed within your tailnet to other nodes!"
  bashio::log.warning "Please reconfigure your subnet routing within your tailnet"
  bashio::log.warning "to prevent current or future collisions."
fi
for route in "${colliding_routes[@]}"; do
  bashio::log.warning "  ${route}"
done
